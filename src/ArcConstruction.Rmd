---
title: "ArcConstruction"
author: "Cheryn"
date: "2025-12-03"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
```

# Locations, Arcs, and Valid Arcs

Use a `$` to refer to a certain column and `[i]` is the row index. These will be turned into dataframes.

Things to think about with arcs:
- If using chunks, you could make a function to assemble each chunk
- scales with workorders

chunking
- hierchical structures with chunking.
- clusters by divergence.
- or clusters by diversity.
- or clusters by distance
- or clusters by workorder similarity
- clusters by driver lots of overnights?
- clusters by reducing availability after each chunk
- we're actually chunking workorders
- cluster by time constraint
- penalize incomplete workorders in relation to the due date.


## Part 1: Locations

Size of locations = 2(drivers COUNT + workorders COUNT)

```{r}

workorders <- read_csv("Chunked Workorders.csv")
workorders <- workorders %>% filter(Chunk_10 == 1)
drivers <- read_csv("Region 1 Drivers.csv")
drivers <- drivers %>% filter(Chunk_9 == 1)


# Thanks ChatGPT:

locations <- bind_rows(
  workorders %>%
    transmute(
      location = Origination,
      purpose  = "pickup",
      entity   = WorkOrderNumber
    ),
  workorders %>%
    transmute(
      location = Destination,
      purpose  = "dropoff",
      entity   = WorkOrderNumber
    ),
  drivers %>%
    transmute(
      location = Start_location,
      purpose  = "start",
      entity   = DriverID
    ),
  drivers %>%
    transmute(
      location = End_location, # identical but point to a different column
      purpose  = "end",
      entity   = DriverID
    )
)

locations
```

## Part 2: Valid Connections

```{r}
valid_connections <- tibble(
  from = c("start", "start", "pickup", "pickup", "dropoff", "dropoff", "dropoff"),
  to = c("pickup", "end", "pickup", "dropoff", "pickup", "dropoff", "end")
)
```

## Part 3: Arcs

Expected Size of Arcs = (2)(drivers COUNT + workorders COUNT)(drivers COUNT + workorders COUNT - 0.5)

(Approximated due to filtering)


Potential improvements
- removing dropoff to pickup of the same order (-1 for each workorder)
- have a filter in the add_variable to make sure that drivers remove
- 10 drivers and 10 workorders would make ~800 arcs and that makes 8000 binaries


```{r}

# Create all pairwise combinations of locations with themselves
arcs <- locations %>%
  # Rename columns for clarity before joining
  rename(
    from_location = location,
    from_purpose  = purpose,
    from_entity   = entity
  ) %>%
  # Cross join: every row with every row
  crossing(
    locations %>% 
      rename(
        to_location = location,
        to_purpose  = purpose,
        to_entity   = entity
      )
  ) %>%
  # Remove self-connections (same row connecting to itself)
  filter(
    !(from_location == to_location &
      from_purpose  == to_purpose &
      from_entity   == to_entity)
  ) %>%
  # Keep only valid purpose â†’ purpose transitions
  semi_join(valid_connections,
            by = c("from_purpose" = "from",
                   "to_purpose"   = "to")
  ) %>%
  # entities have to be the same for from start to end
  filter(
    !(from_purpose == "start" &
      to_purpose   == "end" &
      from_entity  != to_entity)
  )

arcs
```




