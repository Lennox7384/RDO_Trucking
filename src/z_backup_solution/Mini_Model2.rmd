```{r installations02, include=FALSE}
#install.packages("readr")
#install.packages("dplyr")
#install.packages("ompr")
#install.packages("ompr.roi")
#install.packages("ROI.plugin.glpk")
#install.packages("readxl")
#install.packages("janitor")
#install.packages("tidyr")

if (!require("ROI")) install.packages("ROI")

# Load the libraries
library(readr)
library(dplyr)       
library(ompr)        
library(ompr.roi)    
library(ROI.plugin.glpk) 
library(readxl)
library(tidyr)
#library(janitor)
```

```{r data_loading}

# 1. Load the full data
drivers_full     <- read_csv("Drivers.csv")     
locations        <- read_csv("Locations.csv")   
work_orders_full <- read_csv("TruckingWorkorders.csv")
mileage_matrix   <- read_excel("mileageMatrix.xlsx")

# 2. SUBSET TO MINI PROBLEM (10 Drivers, 10 Orders)
# We select just the first 10 rows of each to make the math fast for testing.
drivers     <- drivers_full[1:10, ]
work_orders <- work_orders_full[1:10, ]

# 3. Brief viewing to verify
cat("Mini Problem Created:\n")
cat("Drivers Count:", nrow(drivers), "\n")
cat("Orders Count:", nrow(work_orders), "\n\n")

print(head(drivers))
print(head(work_orders))
```

```{r data_preprocessing}
# --- Pre-Processing & Parameter Creation ---

# --- QUICK ASSUMPTIONS, I'll change these later ---
AVG_LABOR_RATE_PER_HOUR <- 35.00  # $ per hour (regular and overtime averaged)
AVG_COST_PER_MILE       <- 1.80   # $/mile (fuel, maintenance, deadhead penalty)
AVG_SPEED_MPH           <- 50
SERVICE_TIME_PER_LEG    <- 1.0    # 0.5h at origin + 0.5h at destination
EXPECTED_ORIGIN_DELAY   <- (0.08 * 2.0) + (0.015 * 4.0) # 0.22 hours
HOURS_PER_WORKDAY       <- 14     # Max on-duty HOS limit
# --- End of ASSUMPTIONS ---

# --- Step 3: Pre-Processing ---

# 1. Cleaning up the mileage matrix
mileage_lookup <- mileage_matrix %>%
  
  # Turning the matrix table into a long list
  tidyr::pivot_longer(
    cols = -Origination,         #All columns EXCEPT 'Origination'
    names_to = "Destination",    # The column headers become 'Destination'
    values_to = "Distance"       # The cell values become 'Distance'
  ) %>%
  # Fixing the dashes '-' to make sure numbers are numbers
  mutate(
    Distance = ifelse(Distance == "-", "0", Distance), 
    Distance = as.numeric(Distance)                    
  )

# 2. Defining the helper function to get distance
get_distance <- function(orig, dest) {
  # If the city names are the same, distance is 0
  if (orig == dest) return(0)
  
  # Finding a matching row
  val <- mileage_lookup %>%
    filter(Origination == orig, Destination == dest) %>%
    pull(Distance)
  
  # Safety check: if we found nothing (misspelled city?), return a huge number
  if (length(val) == 0) return(99999) 
  
  return(val)
}

# Immediate testing
print(paste("Distance test:", get_distance("Aberdeen, SD", "Bismarck, ND")))


# --- Now, creating a big parameter matrix for all (i, j) pairs ---

# 1. All possible combinations of drivers and workorders
driver_ids <- drivers$DriverID
work_order_ids <- work_orders$WorkOrderNumber

# An empty list to store the parameters
params_list <- list()

# A loop over every driver and every work order
# This is the main "Parameter Generation" loop
for (i in driver_ids) {
  for (j in work_order_ids) {
    
    # Get the specific driver and job details
    driver_row <- filter(drivers, DriverID == i)
    work_order_row <- filter(work_orders, WorkOrderNumber == j)
    
    # --- Pre-filtering For impossible Orders ---
    
    # Load capacity check
    can_handle_load <- driver_row$`Max Load Pounds` >= work_order_row$LoadWeight
    
    # Locations retrieve
    driver_base <- paste0(driver_row$Location, ", ", driver_row$State) 
    work_origin <- work_order_row$Origination
    work_dest <- work_order_row$Destination
    
    # --- Calculating Distances---
    # Trip process: Base -> Origin -> Dest -> Base
    dist_base_to_orig <- get_distance(driver_base, work_origin)
    dist_orig_to_dest <- get_distance(work_origin, work_dest)
    dist_dest_to_base <- get_distance(work_dest, driver_base)
    
    # Total distance for just one job
    total_distance <- dist_base_to_orig + dist_orig_to_dest + dist_dest_to_base
    
    # --- Now calculating Times ---
    
    # 1. Driving-only time (for 70-hour HOS rule)
    drive_time_ij <- total_distance / AVG_SPEED_MPH
    
    # 2. Total Work time (for costs and capacity)
    # (Drive time) + (Service time for 3 legs) + (Expected delay)
    work_time_ij <- drive_time_ij + (3 * SERVICE_TIME_PER_LEG) + EXPECTED_ORIGIN_DELAY
    
    # 3. Checking Deadline
    # Converting work time to days
    work_time_days <- work_time_ij / HOURS_PER_WORKDAY # Using 14h on-duty day
    can_meet_deadline <- work_time_days <= work_order_row$DeliveryDays
    
    # --- Calculating Overnights ---
    # Simple estimate: any job that takes more than 1 on-duty day
    # Or requires a leg longer than 11h driving / 14h on-duty
    drive_leg1 <- dist_base_to_orig / AVG_SPEED_MPH
    drive_leg2 <- dist_orig_to_dest / AVG_SPEED_MPH
    drive_leg3 <- dist_dest_to_base / AVG_SPEED_MPH
    
    # A job requires an overnight if its total work time exceeds one day
    # This is a simplification.
    overnights_ij <- floor(work_time_days)
    
    # --- Calculating Cost ---
    cost_labor <- work_time_ij * AVG_LABOR_RATE_PER_HOUR
    cost_mileage <- total_distance * AVG_COST_PER_MILE
    cost_ij <- cost_labor + cost_mileage
    
    # --- Now Storing all parameters ---
    params_list[[paste(i, j, sep = "_")]] <- data.frame(
      DriverID = i,
      WorkOrderNumber = j,
      Cost_ij = cost_ij,
      WorkTime_ij = work_time_ij,
      DriveTime_ij = drive_time_ij,
      Overnights_ij = overnights_ij,
      MaxOvernight_i = driver_row$MaxNightsOvernightPerWeek,
      # Store the "can-do" flags
      Possible = can_handle_load & can_meet_deadline
    )
  }
}

# Combining into one big data frame
params_df <- bind_rows(params_list)

# --- IMPORTANT: Filtering out impossible jobs ---
# We only want to consider (i, j) pairs that are "Possible" 
params_df <- params_df %>%
  filter(Possible == TRUE)

# Removing any rows with NAs
params_df <- na.omit(params_df)

# We now have our master parameter set.
cat("Parameter generation complete. Found", nrow(params_df), "possible assignments.\n")
```

```{r Paired_route_chaining}
# --- Step 1: Preparing Data for Chaining ---
wo_locations <- work_orders %>%
  select(WorkOrderNumber, Origination, Destination) %>%
  rename(Order_Origin = Origination, Order_Dest = Destination)

params_enhanced <- params_df %>%
  left_join(wo_locations, by = "WorkOrderNumber")

# --- Step 2: The "Self-Join" (Generating Candidates) ---
chain_candidates <- params_enhanced %>%
  inner_join(params_enhanced, by = "DriverID", suffix = c("_1", "_2")) %>%
  filter(WorkOrderNumber_1 != WorkOrderNumber_2)

# --- Step 3: FAST Calculation (Vectorized) ---
# Instead of calculating row-by-row, we join the mileage table directly.
# This is usually 1000x faster.

valid_chains <- chain_candidates %>%
  # Join to get the deadhead distance instantly
  left_join(mileage_lookup, by = c("Order_Dest_1" = "Origination", "Order_Origin_2" = "Destination")) %>%
  
  mutate(
    # Handling missing distances (if cities don't match or are same city)
    # If City A == City B, distance is 0. If not found in table, 99999.
    Deadhead_Dist = case_when(
      Order_Dest_1 == Order_Origin_2 ~ 0,
      is.na(Distance) ~ 99999,
      TRUE ~ Distance
    ),
    
    # Calculating costs/times using columns (Vectorized math is instant)
    Deadhead_Time = Deadhead_Dist / AVG_SPEED_MPH,
    Deadhead_Cost = Deadhead_Dist * AVG_COST_PER_MILE,
    
    Total_Chain_Time = WorkTime_ij_1 + Deadhead_Time + WorkTime_ij_2,
    Total_Chain_Cost = Cost_ij_1 + Cost_ij_2 + Deadhead_Cost,
    Requires_Overnight = ifelse(Total_Chain_Time > HOURS_PER_WORKDAY, 1, 0)
  ) %>%
  
  # --- Step 4: Filtering  ---
  filter(
    Deadhead_Dist < 500,
    case_when(
      MaxOvernight_i_1 == 0 ~ Total_Chain_Time <= HOURS_PER_WORKDAY,
      MaxOvernight_i_1 > 0  ~ Total_Chain_Time <= (HOURS_PER_WORKDAY * 2)
    ),
    Requires_Overnight <= MaxOvernight_i_1
  ) %>%
  
  # Select final columns
  select(
    DriverID,
    Order1 = WorkOrderNumber_1,
    Order2 = WorkOrderNumber_2,
    TotalCost = Total_Chain_Cost,
    TotalTime = Total_Chain_Time,
    Overnights = Requires_Overnight
  )

cat("Chaining complete. Found", nrow(valid_chains), "valid paired routes.\n")
```

```{r Paired_route_chaining}
# --- Step 1: Preparing Data for Chaining ---
wo_locations <- work_orders %>%
  select(WorkOrderNumber, Origination, Destination) %>%
  rename(Order_Origin = Origination, Order_Dest = Destination)

params_enhanced <- params_df %>%
  left_join(wo_locations, by = "WorkOrderNumber")

# --- Step 2: The "Self-Join" (Generating Candidates) ---
chain_candidates <- params_enhanced %>%
  inner_join(params_enhanced, by = "DriverID", suffix = c("_1", "_2")) %>%
  filter(WorkOrderNumber_1 != WorkOrderNumber_2)

# --- Step 3: FAST Calculation (Vectorized) ---
# Instead of calculating row-by-row, we join the mileage table directly.
# This is usually 1000x faster.

valid_chains <- chain_candidates %>%
  # Join to get the deadhead distance instantly
  left_join(mileage_lookup, by = c("Order_Dest_1" = "Origination", "Order_Origin_2" = "Destination")) %>%
  
  mutate(
    # Handling missing distances (if cities don't match or are same city)
    # If City A == City B, distance is 0. If not found in table, 99999.
    Deadhead_Dist = case_when(
      Order_Dest_1 == Order_Origin_2 ~ 0,
      is.na(Distance) ~ 99999,
      TRUE ~ Distance
    ),
    
    # Calculating costs/times using columns (Vectorized math is instant)
    Deadhead_Time = Deadhead_Dist / AVG_SPEED_MPH,
    Deadhead_Cost = Deadhead_Dist * AVG_COST_PER_MILE,
    
    Total_Chain_Time = WorkTime_ij_1 + Deadhead_Time + WorkTime_ij_2,
    Total_Chain_Cost = Cost_ij_1 + Cost_ij_2 + Deadhead_Cost,
    Requires_Overnight = ifelse(Total_Chain_Time > HOURS_PER_WORKDAY, 1, 0)
  ) %>%
  
  # --- Step 4: Filtering  ---
  filter(
    Deadhead_Dist < 500,
    case_when(
      MaxOvernight_i_1 == 0 ~ Total_Chain_Time <= HOURS_PER_WORKDAY,
      MaxOvernight_i_1 > 0  ~ Total_Chain_Time <= (HOURS_PER_WORKDAY * 2)
    ),
    Requires_Overnight <= MaxOvernight_i_1
  ) %>%
  
  # Select final columns
  select(
    DriverID,
    Order1 = WorkOrderNumber_1,
    Order2 = WorkOrderNumber_2,
    TotalCost = Total_Chain_Cost,
    TotalTime = Total_Chain_Time,
    Overnights = Requires_Overnight
  )

cat("Chaining complete. Found", nrow(valid_chains), "valid paired routes.\n")
```


```{r joining_and_routing_valid _orders_both_Singles_and_paired}
# --- Step 1: Formatting the "Singles" ---
# We give them a generic shape: RouteID, Driver, Cost, and a specific "Type"
singles_formatted <- params_df %>%
  mutate(
    RouteType = "Single",
    # We will assign IDs based on row number first
    TempID = row_number()
  ) %>%
  select(DriverID, Cost = Cost_ij, RouteType, TempID, WorkOrderNumber)

# --- Step 2: Formatting the "Pairs" ---
pairs_formatted <- valid_chains %>%
  mutate(
    RouteType = "Pair",
    # Continue IDs where singles left off
    TempID = row_number() + nrow(singles_formatted)
  ) %>%
  select(DriverID, Cost = TotalCost, RouteType, TempID, Order1, Order2)

# --- Step 3: Creating the Master "Route Headers" Table ---
# This is the list the solver will actually choose from (x_1, x_2, etc.)
all_routes <- bind_rows(
  singles_formatted %>% select(DriverID, Cost, RouteType, TempID),
  pairs_formatted %>% select(DriverID, Cost, RouteType, TempID)
) %>%
  rename(RouteID = TempID) # Finalized name

# --- Step 4: Creating the "Route Contents" Mapping ---
# This tells the solver: "If you pick Route X, you satisfy Orders Y and Z"

# Getting singles content
content_singles <- singles_formatted %>%
  select(RouteID = TempID, OrderID = WorkOrderNumber)

# Getting pairs content (needs to be pivoted so Order1 and Order2 are in one column)
content_pairs <- pairs_formatted %>%
  select(RouteID = TempID, Order1, Order2) %>%
  pivot_longer(cols = c(Order1, Order2), values_to = "OrderID") %>%
  select(RouteID, OrderID)

# Combine them
route_orders <- bind_rows(content_singles, content_pairs)

# --- Result ---
cat("Master Menu Created.\n")
cat("Total Options:", nrow(all_routes), "\n")
cat("  - Singles:", nrow(singles_formatted), "\n")
cat("  - Pairs:  ", nrow(pairs_formatted), "\n")

```

```{r Now_Solving}
# --- 1. DATA PREP FOR SOLVER ---
# We need to give the solver simple lists of "Who covers What"

# A. Getting the list of Route IDs for each Driver
# Format: List where name is DriverID, content is vector of RouteIDs
driver_map <- split(all_routes$RouteID, all_routes$DriverID)

# B. Getting the list of Route IDs for each Order
# Format: List where name is OrderID, content is vector of RouteIDs
order_map <- split(route_orders$RouteID, route_orders$OrderID)

# C. Defining the Cost Vector (in order of RouteID)
# Ensuring it is sorted by RouteID so x[1] matches Route 1
costs <- all_routes %>% arrange(RouteID) %>% pull(Cost)
num_routes <- nrow(all_routes)

# --- 2. BUILD THE MODEL ---
cat("Building the optimization model... (This might take a moment)\n")

model <- MIPModel() %>%
  
  # DECISION VARIABLE: x[i]
  # 1 if we pick Route i, 0 if we don't.
  add_variable(x[i], i = 1:num_routes, type = "binary") %>%
  
  # OBJECTIVE: Minimize Total Cost
  set_objective(sum_expr(costs[i] * x[i], i = 1:num_routes), sense = "min") %>%
  
  # CONSTRAINT 1: Each Order must be covered EXACTLY once
  # We loop through every order in our list
  add_constraint(
    sum_expr(x[i], i = order_map[[order_id_str]]) == 1, 
    order_id_str = names(order_map)
  ) %>%

  # CONSTRAINT 2: Each Driver can do AT MOST one route
  # We loop through every driver
  add_constraint(
    sum_expr(x[i], i = driver_map[[driver_id_str]]) <= 1, 
    driver_id_str = names(driver_map)
  )

# --- 3. SOLVE IT ---
cat("Solving... \n")
result <- solve_model(model, with_ROI(solver = "glpk", verbose = TRUE))

# --- 4. EXTRACT RESULTS ---
if (result$status == "optimal" || result$status == "success") {
  cat("Success! Optimal solution found.\n")
  
  # 1. Identify the Winning Routes
  selected_routes <- get_solution(result, x[i]) %>%
    filter(value == 1) %>%
    pull(i)
  
  # 2. Retrieve the Route Details
  # (Join the route ID back to the Order and Driver info)
  final_details <- route_orders %>%
    filter(RouteID %in% selected_routes) %>%
    left_join(all_routes, by = "RouteID") %>%
    select(DriverID, OrderID, RouteType, Cost) %>%
    arrange(DriverID) # Sort by Driver to make it easy to read
  
  # 3. PRINT THE RESULTS
  cat("\n--- FINAL ASSIGNMENTS ---\n")
  cat("Total Cost: $", result$objective_value, "\n")
  cat("Orders Delivered:", nrow(final_details), "\n")
  cat("Drivers Used:", n_distinct(final_details$DriverID), "\n\n")
  
  # Print the actual table of who does what
  print(as.data.frame(final_details))
  
} else {
  cat("Solver status:", result$status, "\n")
  cat("The model could not find a solution.\n")
  cat("Troubleshooting for Mini Problem:\n")
  cat("1. Check if 'possible' logic excluded ALL drivers for a specific order.\n")
  cat("2. Check if you have fewer drivers than orders (Infeasibility).\n")
}
```
