```{r installations02, include=FALSE}
#install.packages("readr")
#install.packages("dplyr")
#install.packages("ompr")
#install.packages("ompr.roi")
#install.packages("ROI.plugin.glpk")
#install.packages("readxl")
#install.packages("janitor")
#install.packages("tidyr")

if (!require("ROI")) install.packages("ROI")

# Load the libraries
library(readr)
library(dplyr)       
library(ompr)        
library(ompr.roi)    
library(ROI.plugin.glpk) 
library(readxl)
library(tidyr)
#library(janitor)
```

```{r data_loading}

# 1. Load the full data
drivers_full     <- read_csv("Drivers.csv")     
locations        <- read_csv("Locations.csv")   
work_orders_full <- read_csv("TruckingWorkorders.csv")
mileage_matrix   <- read_excel("mileageMatrix.xlsx")

# 2. SUBSET TO MINI PROBLEM (10 Drivers, 10 Orders)
# We select just the first 10 rows of each to make the math fast for testing.
drivers     <- drivers_full[1:10, ]
work_orders <- work_orders_full[1:10, ]

# 3. Brief viewing to verify
cat("Mini Problem Created:\n")
cat("Drivers Count:", nrow(drivers), "\n")
cat("Orders Count:", nrow(work_orders), "\n\n")

print(head(drivers))
print(head(work_orders))
```

```{r data_preprocessing}
# --- Pre-Processing & Parameter Creation ---

# --- QUICK ASSUMPTIONS, I'll change these later ---
AVG_LABOR_RATE_PER_HOUR <- 35.00  # $ per hour (regular and overtime averaged)
AVG_COST_PER_MILE       <- 1.80   # $/mile (fuel, maintenance, deadhead penalty)
AVG_SPEED_MPH           <- 50
SERVICE_TIME_PER_LEG    <- 1.0    # 0.5h at origin + 0.5h at destination
EXPECTED_ORIGIN_DELAY   <- (0.08 * 2.0) + (0.015 * 4.0) # 0.22 hours
HOURS_PER_WORKDAY       <- 14     # Max on-duty HOS limit
# --- End of ASSUMPTIONS ---

# --- Step 3: Pre-Processing ---

# 1. Cleaning up the mileage matrix
mileage_lookup <- mileage_matrix %>%
  
  # Turning the matrix table into a long list
  tidyr::pivot_longer(
    cols = -Origination,         #All columns EXCEPT 'Origination'
    names_to = "Destination",    # The column headers become 'Destination'
    values_to = "Distance"       # The cell values become 'Distance'
  ) %>%
  # Fixing the dashes '-' to make sure numbers are numbers
  mutate(
    Distance = ifelse(Distance == "-", "0", Distance), 
    Distance = as.numeric(Distance)                    
  )

# 2. Defining the helper function to get distance
get_distance <- function(orig, dest) {
  # If the city names are the same, distance is 0
  if (orig == dest) return(0)
  
  # Finding a matching row
  val <- mileage_lookup %>%
    filter(Origination == orig, Destination == dest) %>%
    pull(Distance)
  
  # Safety check: if we found nothing (misspelled city?), return a huge number
  if (length(val) == 0) return(99999) 
  
  return(val)
}

# Immediate testing
print(paste("Distance test:", get_distance("Aberdeen, SD", "Bismarck, ND")))


# --- Now, creating a big parameter matrix for all (i, j) pairs ---

# 1. All possible combinations of drivers and workorders
driver_ids <- drivers$DriverID
work_order_ids <- work_orders$WorkOrderNumber

# An empty list to store the parameters
params_list <- list()

# A loop over every driver and every work order
# This is the main "Parameter Generation" loop
for (i in driver_ids) {
  for (j in work_order_ids) {
    
    # Get the specific driver and job details
    driver_row <- filter(drivers, DriverID == i)
    work_order_row <- filter(work_orders, WorkOrderNumber == j)
    
    # --- Pre-filtering For impossible Orders ---
    
    # Load capacity check
    can_handle_load <- driver_row$`Max Load Pounds` >= work_order_row$LoadWeight
    
    # Locations retrieve
    driver_base <- paste0(driver_row$Location, ", ", driver_row$State) 
    work_origin <- work_order_row$Origination
    work_dest <- work_order_row$Destination
    
    # --- Calculating Distances---
    # Trip process: Base -> Origin -> Dest -> Base
    dist_base_to_orig <- get_distance(driver_base, work_origin)
    dist_orig_to_dest <- get_distance(work_origin, work_dest)
    dist_dest_to_base <- get_distance(work_dest, driver_base)
    
    # Total distance for just one job
    total_distance <- dist_base_to_orig + dist_orig_to_dest + dist_dest_to_base
    
    # --- Now calculating Times ---
    
    # 1. Driving-only time (for 70-hour HOS rule)
    drive_time_ij <- total_distance / AVG_SPEED_MPH
    
    # 2. Total Work time (for costs and capacity)
    # (Drive time) + (Service time for 3 legs) + (Expected delay)
    work_time_ij <- drive_time_ij + (3 * SERVICE_TIME_PER_LEG) + EXPECTED_ORIGIN_DELAY
    
    # 3. Checking Deadline
    # Converting work time to days
    work_time_days <- work_time_ij / HOURS_PER_WORKDAY # Using 14h on-duty day
    can_meet_deadline <- work_time_days <= work_order_row$DeliveryDays
    
    # --- Calculating Overnights ---
    # Simple estimate: any job that takes more than 1 on-duty day
    # Or requires a leg longer than 11h driving / 14h on-duty
    drive_leg1 <- dist_base_to_orig / AVG_SPEED_MPH
    drive_leg2 <- dist_orig_to_dest / AVG_SPEED_MPH
    drive_leg3 <- dist_dest_to_base / AVG_SPEED_MPH
    
    # A job requires an overnight if its total work time exceeds one day
    # This is a simplification.
    overnights_ij <- floor(work_time_days)
    
    # --- Calculating Cost ---
    cost_labor <- work_time_ij * AVG_LABOR_RATE_PER_HOUR
    cost_mileage <- total_distance * AVG_COST_PER_MILE
    cost_ij <- cost_labor + cost_mileage
    
    # --- Now Storing all parameters ---
    params_list[[paste(i, j, sep = "_")]] <- data.frame(
      DriverID = i,
      WorkOrderNumber = j,
      Cost_ij = cost_ij,
      WorkTime_ij = work_time_ij,
      DriveTime_ij = drive_time_ij,
      Overnights_ij = overnights_ij,
      MaxOvernight_i = driver_row$MaxNightsOvernightPerWeek,
      # Store the "can-do" flags
      Possible = can_handle_load & can_meet_deadline
    )
  }
}

# Combining into one big data frame
params_df <- bind_rows(params_list)

# --- IMPORTANT: Filtering out impossible jobs ---
# We only want to consider (i, j) pairs that are "Possible" 
params_df <- params_df %>%
  filter(Possible == TRUE)

# Removing any rows with NAs
params_df <- na.omit(params_df)

# We now have our master parameter set.
cat("Parameter generation complete. Found", nrow(params_df), "possible assignments.\n")
```

```{r Paired_route_chaining}
# --- Step 1: Preparing Data for Chaining ---
wo_locations <- work_orders %>%
  select(WorkOrderNumber, Origination, Destination) %>%
  rename(Order_Origin = Origination, Order_Dest = Destination)

params_enhanced <- params_df %>%
  left_join(wo_locations, by = "WorkOrderNumber")

# --- Step 2: The "Self-Join" (Generating Candidates) ---
chain_candidates <- params_enhanced %>%
  inner_join(params_enhanced, by = "DriverID", suffix = c("_1", "_2")) %>%
  filter(WorkOrderNumber_1 != WorkOrderNumber_2)

# --- Step 3: FAST Calculation (Vectorized) ---
# Instead of calculating row-by-row, we join the mileage table directly.
# This is usually 1000x faster.

valid_chains <- chain_candidates %>%
  # Join to get the deadhead distance instantly
  left_join(mileage_lookup, by = c("Order_Dest_1" = "Origination", "Order_Origin_2" = "Destination")) %>%
  
  mutate(
    # Handling missing distances (if cities don't match or are same city)
    # If City A == City B, distance is 0. If not found in table, 99999.
    Deadhead_Dist = case_when(
      Order_Dest_1 == Order_Origin_2 ~ 0,
      is.na(Distance) ~ 99999,
      TRUE ~ Distance
    ),
    
    # Calculating costs/times using columns (Vectorized math is instant)
    Deadhead_Time = Deadhead_Dist / AVG_SPEED_MPH,
    Deadhead_Cost = Deadhead_Dist * AVG_COST_PER_MILE,
    
    Total_Chain_Time = WorkTime_ij_1 + Deadhead_Time + WorkTime_ij_2,
    Total_Chain_Cost = Cost_ij_1 + Cost_ij_2 + Deadhead_Cost,
    Requires_Overnight = ifelse(Total_Chain_Time > HOURS_PER_WORKDAY, 1, 0)
  ) %>%
  
  # --- Step 4: Filtering  ---
  filter(
    Deadhead_Dist < 500,
    case_when(
      MaxOvernight_i_1 == 0 ~ Total_Chain_Time <= HOURS_PER_WORKDAY,
      MaxOvernight_i_1 > 0  ~ Total_Chain_Time <= (HOURS_PER_WORKDAY * 2)
    ),
    Requires_Overnight <= MaxOvernight_i_1
  ) %>%
  
  # Select final columns
  select(
    DriverID,
    Order1 = WorkOrderNumber_1,
    Order2 = WorkOrderNumber_2,
    TotalCost = Total_Chain_Cost,
    TotalTime = Total_Chain_Time,
    Overnights = Requires_Overnight
  )

cat("Chaining complete. Found", nrow(valid_chains), "valid paired routes.\n")
```
